----【代理模式】----

【对象增强的三种方式】
1.继承
2.装饰模式
3.代理模式



【动态代理】
关键方法：
  java.lang.reflect.Proxy.newProxyInstance(ClassLoader, Class<?>[], InvocationHandler)
 * 参数一：生成代理对象使用哪个类装载器【一般我们使用的是被代理类的装载器】
 * 参数二：生成哪个对象的代理对象，通过接口指定【指定要被代理类的接口】
 * 参数三：生成的代理对象的方法里干什么事【实现handler接口，我们想怎么实现就怎么实现】
 
在编写动态代理之前，要明确几个概念：
 1.代理对象拥有目标对象相同的方法【因为参数二指定了对象的接口，代理对象会实现接口的所有方法】
 2.用户调用代理对象的什么方法，都是在调用处理器的invoke方法。【被拦截】
 3.使用JDK动态代理必须要有接口【参数二需要接口】

动态代理具体调用过程：
[Client] 
	--doSth()--> 
[DynamicProxy] 
	--invoke()--> 
[MyInvocationHandler] 
	--"invoke()"--> 
[Subject对象]


【静态代理和动态代理的区别】
1.静态代理需要自己写代理类  --> 代理类需要实现与目标对象相同的借口
2.动态代理不需要自己编写代理类  --> 是动态生成的

使用静态代理时，如果目标对象的接口有很多方法的话，我们还是得一一实现，这样就会比较麻烦
使用动态代理时，代理对象的生成，是利用JDK API，动态在内存中构建代理对象（需要我们制定创建 代理对象/目标对象 实现的接口类型），并且会默认实现接口的全部方法。
 
 
【总结】
要实现动态代理是必须要有接口的，动态代理是基于接口来代理的（实现接口的所有方法），如果没有接口的话可以考虑使用cglib代理。
cglib代理也叫子类代理，从内存中构建出一个子类来扩展目标对象的功能。
Spring 的 AOP 底层其实就是动态代理来实现的。
 
 
 
 相关讲解：
https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484222&idx=1&sn=5191aca33f7b331adaef11c5e07df468&chksm=ebd7423fdca0cb29cdc59b4c79afcda9a44b9206806d2212a1b807c9f5879674934c37c250a1&scene=21#wechat_redirect



----【cglib子类代理及AOP】----

【AOP概述】
AOP: aspect object programming 面向切面编程
  ·功能： 让关注点代码与业务代码分离！
  ·面向切面编程：对很多功能都有的重复的代码抽取，再在运行的时候往业务方法上动态植入“切面类代码”。

关注点：重复的代码就叫做关注点。

切面：关注点形成的类，就叫切面（类）！ 

切入点：
  ·执行目标对象方法，动态植入切面代码。
  ·可以通过切入点表达式，指定拦截哪些类的哪些方法；给指定的类在运行的时候植入切面类代码。
  
切入点表达式：指定哪些类的哪些方法被拦截。


 